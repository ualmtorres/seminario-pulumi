////
NO CAMBIAR!!
Codificación, idioma, tabla de contenidos, tipo de documento
////
:encoding: utf-8
:lang: es
:toc: right
:toc-title: Tabla de contenidos
:doctype: book
:imagesdir: ./images
:linkattrs:

////
Nombre y título del trabajo
////
# Infraestructura como código con Pulumi
Servicio de las Tecnologías de la Información y las Comunicaciones - Universidad de Almería

image::logocloudstic.png[]

// NO CAMBIAR!! (Entrar en modo no numerado de apartados)
:numbered!: 


[abstract]
== Resumen
////
COLOCA A CONTINUACION EL RESUMEN
////
Los produtos habituales para la Infraestructura como código, como Terraform, Ansible, Chef, Puppet, y demás, suelen contar con su propia sintaxis, lo que dificulta en cierta medida su uso. Pulumi permite la creación de la infraestructura usando lenguajes de programación populares, como TypeScript, JavaScript, Python, Go o C#. De esta forma podemos usar nuestro lenguaje habitual para la creación de la infraestructura de forma sencilla, sin tener que pasar a otro lenguaje y beneficiándonos del manejo de variables y construcciones de programación habituales como los bucles y condiciones, aspectos básicos pero que no son demasiado sencillos de usar en el resto de productos.

////
COLOCA A CONTINUACION LOS OBJETIVOS
////
.Objetivos
* Aprender a hacer despliegues de proyectos sencillos.
* Realizar cambios sobre la infraestructura.
* Gestionar errores de despliegues corruptos.

[TIP]
====
[line-through]##Disponible el https://github.como/ualmtorres[repositorio] usado en este tutorial##.
====

// Entrar en modo numerado de apartados
:numbered:

## Introducción

La Infraestructura como código (IaC, Infrastructure as Code) permite la definición y mantenimiento de la infraestructura mediante código. Esto permite la automatización de la creación de la infraestructura en lugar de hacerlo manualmente. Se trata de un proceso declarativo en el que mediante una serie de archivos se especifica de forma declarativa la infraestructura y la configuración que se necesita (p.e. un entorno de backend con un volumen de almacenamiento, una máquina virtual con MySQL instalado y conectada al volumen creado, una máquina virtual con un framework instalado como Express, la configuración de red y de grupos de seguridad, ....). De esta forma se evita tener que preparar manualmente las máquinas virtuales, sistemas operativos, almacenamiento y configuración, obteniéndose en su lugar la definición de un entorno que garantiza ser replicable, documentando las especificaciones y evitando la realización de cambios sobre marcha y que no queden documentados. Con IaC, los cambios se hacen sobre el código y se aplican ejecutándola, en lugar de hacerlos en caliente mediante comandos sobre la infraestructura. Además, la práctica de control de versiones, como cualquier otro desarrollo software, permitirá llevar un control de cada uno de los cambios introducidos en la configuración de la infraestructura. 

Entre los productos más populares de IaC se encuentran Terraform, Ansible, Chef, Puppet, ... En estas propuestas, la infraestructura se especifica de formas muy variadas, como en https://ualmtorres.github.io/CursoAnsible/tutorial/#trueinstalaci-n-de-paquetes[formato YAML] en el caso de Ansible, o en su propio lenguaje DSL (Domain Specific Language) como el https://github.com/ualmtorres/terraform-examples/blob/master/GCP/05-instancia-aprovisionada/main.tf[HCL] (Hashicorp Configuration Language) de Terraform y el https://puppet.com/docs/puppet/7/lang_visual_index.html#lang_examples_resource-resource-declaration[Puppet Language] de Puppet, pasando por Chef, que usa https://www.tutorialspoint.com/chef/chef_testing_cookbooks.htm[Ruby como sintaxis] para la definición de la infraestructura. 

[NOTE]
====
En estos enlaces puedes consultar otros tutoriales sobre https://ualmtorres.github.io/SeminarioTerraform/[Terraform] y https://ualmtorres.github.io/CursoAnsible/tutorial/[Ansible].
====

En este contexto surge https://www.pulumi.com/[Pulumi], un nuevo producto de IaC que se diferencia del resto en que usa lenguajes de programación convencionales, como TypeScript, JavaScript, Python, Go o C#. Esto lo hace especialmente interesante, ya que no se tendrá que aprender un lenguaje extra para el manejo de infraestructura cloud y se facilita el uso de variables y construcciones de programación como bucles y condiciones.

Pulumi ofrece soporte para lo principales proveedores cloud, como Amazon, Google Cloud, Microsoft Azure, Digital Ocean, Linode, OpenStack, vSphere, y demás, así como para Kubernetes, proveedores de infraestructura, bases de datos, monitorización y sistemas de control de versiones.

En este tutorial nos centraremos en la creación de un cluster de Kubernetes gestionado con Rancher y usando OpenStack como proveedor de infraestructura. Usaremos TypeScript como lenguaje de desarrollo


## Configuración de Pulumi

La instalación la haremos siguiendo la https://www.pulumi.com/docs/get-started/install/[guía oficial de instalación]. 

* En macOS la haremos mediante https://brew.sh/[Homebrew] con `brew install pulumi`.
* En Windows la haremos mediante https://chocolatey.org/[Chocolatey] con `choco install pulumi`.
* En Linux la haremos ejecutando el script `curl -fsSL https://get.pulumi.com | sh`.

Una vez instalado comprobaremos que todo es correcto con:

[source, bash]
----
$ pulumi version
v3.7.0
----

## Flujo de trabajo con Pulumi

El flujo de trabajo habitual en Pulumi consiste en la creación del proyecto, codificación de la infraestuctura inicial, despliegue de cambios. Sin embargo, no se trata de un proceso secuencial, sino que en realidad, tras la creación del proyecto, se entra en un ciclo iterativo de codificación de infraestructura y despliegue de cambios.

El proyecto se crea con el comando `pulumi new` y normalmente le pasaremos una plantilla como argumento. En la plantilla se configura la plataforma con la que vamos a trabajar (proveedor cloud, base de datos, ...) y el lenguaje de programación que vamos a utilizar para codificar la infraestructura. Esto lo veremos en el apartado <<Creación y configuración inicial del proyecto>>.

Los cambios introducidos en el ciclo de desarrollo con Pulumi pueden deberse a la creación de código para nuevos recursos, y modificación o eliminación del código de recursos creados previamente. La forma de llevar a cabo estos cambios siempre es con `pulumi up`. Tras confirmar la acción de despliegue, los cambios se trasladarán a la infraestructura y Pulumi guardará _el estado del despliegue_, que consiste en anotar cada uno de los recursos configurados.

Cuando más adelante se introduzcan cambios en el código y se incluya nuevo código para nuevos recursos, y se modifique o elimine código de recursos creados previamente se comparará el último estado guardado del proyecto con el nuevo estado al que se llegaría tras aplicar los cambios. Tras confirmar la acción de despliegue, Pulumi sólo desplegaría los cambios, dejando intacto los recursos que no han sido modificados. En este sentido se dice que Pulumi es `idempotente` ya que no vuelve a crear un recurso que no ha sido modificado.

[NOTE]
====
Si eliminamos un recurso del código y ejecutamos `pulumi up` se eliminará ese recurso de la infraestructura. Por tanto, no hay operaciones de eliminación para cada recurso. Simplemente se elimina su código del proyecto y se despliegan los cambios comn `pulumi up`.
====

La infraestructura creada se elimina con `pulumi destroy`. Es una operación peligrosa ya que elimina toda la infraestructura y si hay datos o configuraciones almacenadas en el despliegue se corre el riesgo de pérdida de datos.

## Caso de uso. Creación de una máquina virtual configurada con Rancher en OpenStack

El caso de uso que estudiaremos parte de un proyecto OpenStack creado previamente. En dicho proyecto se configurarán mediante Pulumi los grupos de seguridad, se creará una instancia que se aprovisionará durante su inicio con Rancher y se finalizará asignándole una dirección IP flotante.

### Recursos del paquete Pulumi para OpenStack

De acuerdo con la https://www.pulumi.com/docs/reference/pkg/openstack/[documentación del paquete Pulumi para OpenStack], existen gran cantidad de módulos para la gestión de recursos OpenStacl con Pulumi, entre los que destacan almacenamiento de bloques para Cinder, instancias de cómputo para Nova, identidades para Keystone, imágenes para Glance, redes para Neutron y shares para Manila.

### Descarga de las credenciales del proyecto OpenStack

Desde la interfaz gráfica Horizon de OpenStack seguiremos estos casos para la descarga de credenciales del usuario en el proyecto OpenStack a utilizar.

* Seleccionar el proyecto en OpenStack en el desplegable de proyectos del usuario.
* En el desplegable del menú del usuario seleccionar `OpenStack RC File`.
* Cargar las credenciales descargadas con `source <credentials-filename>`. Introducir la contraseña solicitada de acceso a OpenStack.

[TIP]
====
Para usuarios de Windows se recomienda tener instalado https://ubuntu.com/wsl[WSL]. 
====

### Creación y configuración inicial del proyecto

Desde dentro de un directorio vacío creado para el proyecto crearemos el proyecto Pulumi con el comando `pulumi new`. Si no indicamos nada más, habrá que seleccionar el tipo de proyecto eligiendo tanto la plataforma como el lenguaje. A esta combinación de tipo de proyecto (AWS, Azure, Google Cloud, Kubernetes, Linode, OpenStack) y lenguaje (Go, JavaScript, TypeScript, Python, C#) se le conoce como plantilla. Una forma más rápida es pasar el parámetro de configuración de la plantilla directamente al crear el proyecto

[source,bash]
----
$ pulumi new openstack-typescript <1>
----
<1> Nuevo proyecto usando la plantilla con OpenStack como provider y TypeScript como lenguaje.

A continuación:

* aceptaremos el nombre del proyecto, cuyo valor predeterminado es el del directorio en el que se encuentra
* completaremos la descripción con `Configuración de MV OpenStack`
* aceptaremos el nombre del stack (`dev`).

[NOTE]
====
Un stack es un concepto similar al de entorno de despliegue de aplicaciones. Podremos tener stacks diferentes para desarrollo, staging y producción.
====

Una vez aceptadas las opciones de creación del proyecto se instalarán las dependencias del proyecto y uno instantes después el proyecto estará listo para ejecutarse. 

Como resultado tendremos un proyecto con la estructura siguiente:

[source,]
----
├── .gitignore
├── index.ts <1>
├── package.json <2>
├── Pulumi.yaml <3>
└── tsconfig.json
----
<1> Archivo con los recursos a desplegar. Incopora un ejemplo 
<2> Archivo de dependencias. La dependencia de OpenStack aparece como instalada al haber creado el proyecto con una plantilla de OpenStack
<3> Configuración del nombre y descripción del proyecto y runtime de ejecución

.Una instancia como ejemplo de recurso de OpenStack
****
Tras crear el proyecto con la plantilla de OpenStack, Pulumi incluye un ejemplo de recurso en el archivo `index.ts`. Se trata de la creación de una instancia OpenStack.

[source, ts]
----
...
import * as os from "@pulumi/openstack"; <1>

const instance = new os.compute.Instance("test", { <2>
	flavorName: "s1-2",
	imageName: "Ubuntu 16.04",
});
...
----
<1> Importación del paquete de recursos de OpenStack
<2> Creación de una instancia

Para la creación de la instancia:

* Se usa `os` como alias dado al paquete OpenStack.
* Se usa el módulo `compute` y el recurso `Instance`. 
* Se asigna un nombre (`test` en este caso)
* Se usa un objeto JSON para especificar los  https://www.pulumi.com/docs/reference/pkg/openstack/compute/instance/[ parámetros de configuración]. 
****

### Configuración de las reglas de seguridad

Las reglas de seguridad configuran el cortafuegos del proyecto de OpenStack. Para el ejemplo que nos ocupa, Rancher necesita inicialmente que estén abiertos los puertos TCP 80 y 443 para el tráfico HTTP (HTTP y HTTPS). Para implementarlo podemos incluir estas dos reglas de seguridad en el grupo `default` del proyecto o crear un grupo de seguridad específico para estas dos reglas. Posteriormente, al configurar la instancia se le aplicaría el grupo de seguridad `default` o el grupo específico para las reglas HTTP.En este ejemplo optamos por crear un grupo de seguridad específico.

[IMPORTANT]
====
Crear grupos de seguridad específicos para grupos de reglas de reglas de seguriddad es más laborioso que ir incluyendo las reglas en el grupo `default`. Sin embargo, provoca que haya instancias que tengan abiertos puertos de forma innecesaria, lo que puede derivar en un problema de seguridad. 
====

#### Creación de un grupo de seguridad

Los grupos de seguridad se crean con el recurso `SecGroup` del módulo `networking`. Basta con indicar un nombre para el grupo de seguridad y un JSON para las opciones. En nuestro caso incluiremos la descripción del grupo de seguridad.

[source,ts]
----
const webSecGroup = new os.networking.SecGroup("web", {
	description: "Web security group"
})
----

Esto define un grupo de seguridad asignado a `webSecGroup` lo que nos permite manipularlo posteriormente, como para añadirle reglas de seguridad.

#### Añadir reglas de seguridad

Las reglas de seguridad se añaden a los grupos de seguridad creando un recurso `SecGroupRule` del módulo `networking`. Se trata de indicar un nombre para la reglas de seguridad y un JSON para las opciones. En nuestro caso incluiremos una descripción, dirección, si es IPv4 o IPv6, el puerto abierto (definido como un rango), el protocolo, las direcciones IP remotas a las que se les da acceso y el grupo de seguridad al que se asigna la regla creada

[source,ts]
----
const web80 = new os.networking.SecGroupRule("web80", {
	description: "HTTP",
    direction: "ingress",
    ethertype: "IPv4",
    portRangeMax: 80,
    portRangeMin: 80,
    protocol: "tcp",
    remoteIpPrefix: '0.0.0.0/0',
    securityGroupId: webSecGroup.id, <1>
});

const web443 = new os.networking.SecGroupRule("web443", {
	description: "HTTPS",
    direction: "ingress",
    ethertype: "IPv4",
    portRangeMax: 443,
    portRangeMin: 443,
    protocol: "tcp",
    remoteIpPrefix: '0.0.0.0/0',
    securityGroupId: webSecGroup.id, <2>
});
----
<1> Asignación de la regla a un grupo de seguridad.
<2> Asignación de la regla a un grupo de seguridad.

#### Despliegue de la configuración de seguridad

La configuración de seguridad completa para un entorno con Rancher y Kubernetes residiendo en el mismo proyecto OpenStack incluye una gran variedad de grupos y reglas de seguridad. La documentación oficial de Rancher especifica la https://rancher.com/docs/rancher/v2.x/en/installation/requirements/ports/#ports-for-rancher-launched-kubernetes-clusters-using-node-pools[lista de puertos a abrir] para cada componente. 

Hacer una definición exhaustiva de todos los grupos y reglas de seguridad de un proyecto para producción está fuera del ámbito de este tutorial y nos limitaremos a incluir otro grupo de seguridad a modo de ejemplo para ver cómo configurar varios grupos de seguridad. Tomaremos como ejemplo la configuración de seguridad de los puertos 2379 y 2380 de la base de datos `etcd` que usa Kubernetes para el almacenamiento de la configuración.

Finalmente, la configuración inicial de seguridad quedaría definida así en el archivo `index.ts`.

[source,ts]
----
import * as os from "@pulumi/openstack";

const cidr = '192.168.129.0/24' <1>

// Create security group <2>
const etcdSecGroup = new os.networking.SecGroup("etcd", {
	description: "Kubernetes security group"
})

// Create security rule and assing to a security group <3>
const etcd2379 = new os.networking.SecGroupRule("etcd2379", {
	description: "etcd",
    direction: "ingress",
    ethertype: "IPv4",
    portRangeMax: 2379,
    portRangeMin: 2379,
    protocol: "tcp",
    remoteIpPrefix: cidr, <4>
    securityGroupId: etcdSecGroup.id, <5>
});

// Create security rule and assing to a security group
const etcd2380 = new os.networking.SecGroupRule("etcd2380", {
	description: "etcd",
    direction: "ingress",
    ethertype: "IPv4",
    portRangeMax: 2380,
    portRangeMin: 2380,
    protocol: "tcp",
    remoteIpPrefix: cidr,
    securityGroupId: etcdSecGroup.id,
});

// Create web security group
const webSecGroup = new os.networking.SecGroup("web", {
	description: "Web security group"
})

// Create security rule and assing to a security group
const web80 = new os.networking.SecGroupRule("web80", {
	description: "HTTP",
    direction: "ingress",
    ethertype: "IPv4",
    portRangeMax: 80,
    portRangeMin: 80,
    protocol: "tcp",
    remoteIpPrefix: '0.0.0.0/0',
    securityGroupId: webSecGroup.id,
});

// Create security rule and assing to a security group
const web443 = new os.networking.SecGroupRule("web443", {
	description: "HTTPS",
    direction: "ingress",
    ethertype: "IPv4",
    portRangeMax: 443,
    portRangeMin: 443,
    protocol: "tcp",
    remoteIpPrefix: '0.0.0.0/0',
    securityGroupId: webSecGroup.id,
});

----
<1> CIDR para restringir el acceso remoto a instancias que se apliquen reglas de seguridad para ese CIDR
<2> Creación de un grupo de seguridad
<3> Creación de una regla para un grupo de seguridad
<4> Aplicación del CIDR a la regla de seguridad
<5> Asignación de la regla de seguridad a un grupo de seguridad

Los cambios se desplegarían con `pulumi up` y seleccionando la opción `yes`. La opción `details` muestra los detalles de cada uno de los recursos a crear, modificar o eliminar en la infraestructura.

[NOTE]
====
Si al realizar el despliegue nos aparece el error `One of 'auth_url' or 'cloud' must be specified` se debe a que no se han cargado las credenciales de OpenStack. Consultar el apartado <<Descarga de las credenciales del proyecto OpenStack>>.
====

La figura siguiente muestra el efecto del despliegue con los dos grupos de seguridad creados.

image::grupos-de-seguridad.png[]

La figura siguiente ilustra las reglas de seguridad del grupo `web`. Para ese grupo se permitía el acceso a estos puertos desde cualquier dirección de Internet.

image::reglas-de-seguridad-web.png[]

### Creación de la instancia

Tras definir los grupos de seguridad aplicables a la instancia continuamos ahora con la creación de un recurso de instancia en OpenStack, lo que nos permitirá tener una máquina virtual desplegada con código mediante Pulumi.

Las instancias de OpenStack en Pulumi se crean con el recurso `Instance` del módulo `compute`. Basta con indicar un nombre para la instancia y un JSON para las opciones. En nuestro caso incluiremos la zona de disponibilidad, el nombre de la imagen tay como está definida en OpenStack, el nombre del _flavour_ o sabor a utilizar para crear la instancia, las redes a las que se conectará la instancia, el nombre del par de claves a inyectar en la instancia y los grupos de seguridad. Además, incluiremos un script de inicialización de la instancia en su creación (lo que se conoce como _user data_ en otros sistemas). En la sección <<Script de inicialización de Rancher>> se aportan los detalles de este script. Este script instalará Docker en la máquina virtual y ejecutará Rancher con Docker.

El fragmento siguiente ilustra el código para la creación de una instancia en el archivo `index.ts`

[source,ts]
----
import * as os from "@pulumi/openstack";

const fs = require('fs') <1>
...
// Create an OpenStack resource (Compute Instance)
const rancherInstance = new os.compute.Instance("rancher-sistemas-prod", {
	availabilityZone: "stic-prod",
	imageName: "Ubuntu 18.04 LTS",
	flavorName: "large",
	networks: [
		{
            name: "Sistemas-prod-net",
        }
	],
	keyPair: "os-sistemas",
	userData: fs.readFileSync('./rancher-setup.sh', 'utf8'), <2>
	securityGroups: [etcdSecGroup.name, webSecGroup.name] <3>
});
...
----
<1> Paquete TypeScript para la interacción con archivos.
<2> Carga del archivo que contiene el script de inicialización. **Importante usar utf8**.
<3> Lista de grupos de seguridad a aplicar a la instancia.

Los cambios se desplegarían con `pulumi up` y seleccionando la opción `yes`. La opción `details` muestra los detalles de cada uno de los recursos a crear, modificar o eliminar en la infraestructura.

La figura siguiente muestra el efecto del despliegue con la instancia creada.

image::instancia-creada.png[]

### Asignación de IP flotante

Para poder acceder a la instancia desde el exterior asignaremos una dirección IP flotante. En nuestro caso ya tenemos la dirección IP flotante adjudicada al proyecto y está registrada en un DNS. Por tanto, no será necesario crear la dirección IP flotante en el proyecto, sino que pasaremos directamente al paso de asignar la dirección IP flotante a la instancia. Después veremos cómo sería el script si hubiese que crear la dirección IP flotante.

Las direcciones IP flotantes de OpenStack en Pulumi se asignan con el recurso `FloatingIpAssociate` del módulo `compute`. Basta con indicar un nombre para la asociación de la IP y un JSON para las opciones. En nuestro caso incluiremos la dirección IP flotante y el identificador de la instancia de Rancher.

El fragmento siguiente ilustra el código para la creación de una instancia en el archivo `index.ts`

[source,ts]
----
...
const floatingIP = '192.168.129.1' <1>
...
// Associate a floating IP to the instance
const fipFloatingIpAssociate = new os.compute.FloatingIpAssociate("fip", {
    floatingIp: floatingIP, <2>
    instanceId: rancherInstance.id, <3>
});
...
----
<1> Dirección IP flotante a utilizar disponible previamente en el proyecto OpenStack
<2> String con la dirección IP flotante
<3> Identificador de la instancia

Los cambios se desplegarían con `pulumi up` y seleccionando la opción `yes`. La opción `details` muestra los detalles de cada uno de los recursos a crear, modificar o eliminar en la infraestructura.

La figura siguiente muestra el efecto del despliegue con la dirección IP flotante asignada a la instancia.

image::ip-flotante-asignada.png[]

La figura siguiente ilustra los detalles de la instancia con la dirección IP flotante asignada y los grupos de seguridad configurados.

image::instancia-configurada.png[]

.Creación de una dirección IP flotante
****
Si el proyecto no tiene reservada previamente la dirección IP flotante que vamos a usar, necesitamos crear una nueva.

Las direcciones IP flotantes de OpenStack en Pulumi se crean con el recurso `FloatingIp` del módulo `networking`. Basta con indicar un nombre para la dirección IP flotante y un JSON para las opciones. En nuestro caso incluiremos el nombre del pool de direcciones IP flotantes de OpenStack (en nuestro caso es `ual-net`).

[source,ts]
----
...
const rancherFloatingIp = new openstack.networking.FloatingIp("rancherFloatingIP", {
    pool: "ual-net",
});
...
----

A continuación asignaríamos la dirección IP flotante recién creada a la instancia creada. El proceso es similar al realizado anteriormente, pero sustituyendo la dirección IP en forma de cadena por la dirección IP flotante recién creada.

[source,ts]
----
...
// Associate a floating IP to the instance
const fipFloatingIpAssociate = new os.compute.FloatingIpAssociate("fip", {
    floatingIp: rancherFloatingIp.address, <1>
    instanceId: rancherInstance.id, 
});
...
----
<1> Dirección IP flotante creada.
****

### Script de inicialización de Rancher

[source,bash]
----
#!/bin/bash

RANCHERPASSWORD='yourpasswordhere' <1>
RANCHERSERVER='https://your.url.here.com' <2>

echo "Instalando Docker" <3>

apt-get update
apt-get install -y \
    apt-transport-https \
    ca-certificates \
    curl \
    software-properties-common \
    jq
curl -fsSL https://download.docker.com/linux/ubuntu/gpg | apt-key add -
apt-key fingerprint 0EBFCD88
add-apt-repository \
   "deb [arch=amd64] https://download.docker.com/linux/ubuntu \
   $(lsb_release -cs) \
   stable"
apt-get update
apt-get install -y docker-ce
groupadd docker
usermod -aG docker ubuntu
systemctl enable docker

echo "Obteniendo certificados" 

mkdir /home/ubuntu/rancherdata
mkdir /home/ubuntu/certificados <4>

wget -O /home/ubuntu/certificados/star_stic_ual_es.crt https://your.certificate.server.here.com/star_stic_ual_es_completa.crt
wget -O /home/ubuntu/certificados/star_stic_ual_es.key https://your.certificate.server.here.com/star_stic_ual_es.key
wget -O /home/ubuntu/certificados/DigiCertCA.crt https://your.certificate.server.here.com/DigiCertCA.crt

docker run \ <5>
    --privileged -d \
    --restart=unless-stopped \
    -p 80:80 -p 443:443 \
    -v /home/ubuntu/rancherdata:/var/lib/rancher \
    -v /home/ubuntu/certificados/star_stic_ual_es.crt:/etc/rancher/ssl/cert.pem \
    -v /home/ubuntu/certificados/star_stic_ual_es.key:/etc/rancher/ssl/key.pem \
    -v /home/ubuntu/certificados/DigiCertCA.crt:/etc/rancher/ssl/cacerts.pem \
    --name rancher \
    rancher/rancher:v2.5.8 \
    --features=unsupported-storage-drivers=true <6>

echo "Configurando Rancher"

while ! curl -k https://localhost/ping; do sleep 3; done <7>

# First Rancher Login
LOGINRESPONSE=`curl -s <8> 'https://127.0.0.1/v3-public/localProviders/local?action=login' -H 'content-type: application/json' --data-binary '{"username":"admin","password":"admin"}' --insecure`
LOGINTOKEN=`echo $LOGINRESPONSE | jq -r .token` <9>

# Change password <10>
curl -s 'https://127.0.0.1/v3/users?action=changepassword' \
    -H 'content-type: application/json' \
    -H "Authorization: Bearer $LOGINTOKEN" \
    --data-binary '{"currentPassword":"admin","newPassword":"'$RANCHERPASSWORD'"}' \
    --insecure

# Configure server-url <11>
curl -s 'https://127.0.0.1/v3/settings/server-url' \
    -H 'content-type: application/json' \
    -H "Authorization: Bearer $LOGINTOKEN" \
    -X PUT \
    --data-binary '{"name":"server-url","value":"'$RANCHERSERVER'"}' \
    --insecure

# Activate OpenStack node driver <12>
curl -s 'https://127.0.0.1/v3/nodeDrivers/openstack?action=activate' \
    -H 'content-type: application/json' \
    -H "Authorization: Bearer $LOGINTOKEN" \
    -X POST \
    --insecure

exit 0
----
<1> Variable con la contraseña de administrador
<2> Variable con nombre DNS a asignar a Rancher
<3> Instalación de paquetes necesarios para Docker
<4> Descarga de certificados
<5> Iniciar un contenedor Rancher con los certificados descargados anteriormente
<6> Activar los drivers de almacenamiento experimentales para permitir el uso de OpenStack Cinder como proveedor de almacenamiento
<7> Esperar a que Rancher esté activo 
<8> Usar la API de Rancher con las credenciales `admin/admin` y capturar la respuesta
<9> Obtener el token de login a partir de la llamada anterior
<10> Usar la API de Rancher con el token de login para configurar la nueva contraseña con la variable configurada al inicio del script
<11> Usar la API de Rancher con el token de login para configurar el nombre DNS con la variable configurada al inicio del script
<12> Usar la API de Rancher con el token de login para activar el driver de OpenStack

La figura siguiente muestra Rancher disponible tras el inicio de la instancia

image::rancher.png[]

La figura siguiente muestra activada las características de drivers de almacenamiento no soportados para permitir el uso de volúmenes de OpenStack Cinder.

image::driver-cinder.png[]

La figura siguiente muestra activado el driver de OpenStack para la creación de nodos Kubernetes 

image::openstack-node-driver.png[]

### Reorganización del código

Hemos ido creando recursos poco a poco, comenzando con los grupos de seguridad para centrarnos posteriormente en la creación de la instancia. Actualmente tenemos toda la configuración de la infraestructura en un único archivo `index.ts`. A medida que incorporemos nuevos grupos de seguridad, nuevas reglas, nuevas instancias, el código se hará inmanejable. Actualmente, el archivo `index.js` luce de esta manera.

.`index.ts` con todos los recursos juntos
====
[source,ts]
----
import * as os from "@pulumi/openstack";
import * as sg from './security-groups'

const cidr = '192.168.129.0/24'
const floatingIP = '192.168.129.1'
const fs = require('fs')

// Create security group
const etcdSecGroup = new os.networking.SecGroup("etcd", {
	description: "Kubernetes security group"
})

// Create security rule and assing to a security group
const etcd2379 = new os.networking.SecGroupRule("etcd2379", {
	description: "etcd",
    direction: "ingress",
    ethertype: "IPv4",
    portRangeMax: 2379,
    portRangeMin: 2379,
    protocol: "tcp",
    remoteIpPrefix: cidr,
    securityGroupId: etcdSecGroup.id,
});

// Create security rule and assing to a security group
const etcd2380 = new os.networking.SecGroupRule("etcd2380", {
	description: "etcd",
    direction: "ingress",
    ethertype: "IPv4",
    portRangeMax: 2380,
    portRangeMin: 2380,
    protocol: "tcp",
    remoteIpPrefix: cidr,
    securityGroupId: etcdSecGroup.id,
});

// Create web security group
const webSecGroup = new os.networking.SecGroup("web", {
	description: "Web security group"
})

// Create security rule and assing to a security group
const web80 = new os.networking.SecGroupRule("web80", {
	description: "HTTP",
    direction: "ingress",
    ethertype: "IPv4",
    portRangeMax: 80,
    portRangeMin: 80,
    protocol: "tcp",
    remoteIpPrefix: '0.0.0.0/0',
    securityGroupId: webSecGroup.id,
});

// Create security rule and assing to a security group
const web443 = new os.networking.SecGroupRule("web443", {
	description: "HTTPS",
    direction: "ingress",
    ethertype: "IPv4",
    portRangeMax: 443,
    portRangeMin: 443,
    protocol: "tcp",
    remoteIpPrefix: '0.0.0.0/0',
    securityGroupId: webSecGroup.id,
});

// Create an OpenStack resource (Compute Instance)
const rancherInstance = new os.compute.Instance("rancher-sistemas-prod", {
	availabilityZone: "stic-prod",
	imageName: "Ubuntu 18.04 LTS",
	flavorName: "large",
	networks: [
		{
            name: "Sistemas-prod-net",
        }
	],
	keyPair: "os-sistemas",
	userData: fs.readFileSync('./rancher-setup.sh', 'utf8'),
	securityGroups: [etcdSecGroup.name, webSecGroup.name]
});

// Associate a floating IP to the instance
const fipFloatingIpAssociate = new os.compute.FloatingIpAssociate("fip", {
    floatingIp: floatingIP,
    instanceId: rancherInstance.id,
});

----
====

La refactorización que se propone consiste en:

* Crear un archivo de variables (`values.ts`) en el que se configuran los valores de las variables a utilizar. En este ejemplo configuraremos el CIDR para permitir el acceso desde direcciones IP remotas y la dirección IP flotante que tenemos reservada para Rancher.
* Separar la configuración de los grupos y reglas de seguridad en un archivo aparte (`security-groups.ts`)
* Mantener en `index.ts` sólo las configuración de la instancia de Rancher y la asignación a la IP flotante.

A continuación se muestra el código de cada uno de estos archivos tras la refactorización.

.`values.ts` con los valores de configuración del despliegue
====
[source,ts]
----
const cidr = '192.168.129.0/24'
const floatingIP = '192.168.129.1'

export {cidr, floatingIP} <1>
----
<1> Constantes exportadas para ser reutilizadas
====

.`security-groups.ts` con la configuración de los grupos y reglas de seguridad del despliegue
====
[source,ts]
----
import * as os from "@pulumi/openstack";
import * as values from './values' <1>

// Create security group
const etcdSecGroup = new os.networking.SecGroup("etcd", {
	description: "Kubernetes security group"
})

// Create security rule and assing to a security group
const etcd2379 = new os.networking.SecGroupRule("etcd2379", {
	description: "etcd",
    direction: "ingress",
    ethertype: "IPv4",
    portRangeMax: 2379,
    portRangeMin: 2379,
    protocol: "tcp",
    remoteIpPrefix: values.cidr, <2>
    securityGroupId: etcdSecGroup.id,
});

// Create security rule and assing to a security group
const etcd2380 = new os.networking.SecGroupRule("etcd2380", {
	description: "etcd",
    direction: "ingress",
    ethertype: "IPv4",
    portRangeMax: 2380,
    portRangeMin: 2380,
    protocol: "tcp",
    remoteIpPrefix: values.cidr, 
    securityGroupId: etcdSecGroup.id,
});

// Create web security group
const webSecGroup = new os.networking.SecGroup("web", {
	description: "Web security group"
})

// Create security rule and assing to a security group
const web80 = new os.networking.SecGroupRule("web80", {
	description: "HTTP",
    direction: "ingress",
    ethertype: "IPv4",
    portRangeMax: 80,
    portRangeMin: 80,
    protocol: "tcp",
    remoteIpPrefix: '0.0.0.0/0',
    securityGroupId: webSecGroup.id,
});

// Create security rule and assing to a security group
const web443 = new os.networking.SecGroupRule("web443", {
	description: "HTTPS",
    direction: "ingress",
    ethertype: "IPv4",
    portRangeMax: 443,
    portRangeMin: 443,
    protocol: "tcp",
    remoteIpPrefix: '0.0.0.0/0',
    securityGroupId: webSecGroup.id,
});

export {webSecGroup, etcdSecGroup} <3>
----
<1> Importación del archivo de parámetros y configuración del prefijo `values` para usar los objetos que ha exportado
<2> Uso de los parámetros del archivo de parámetros
<3> Se exportan los grupos de seguridad para poder ser reutilizadas
====

.`index.ts` con la configuración de la instancia del despliegue con la asignación de una IP flotante asignada previamente al proyecto
====
[source,ts]
----
import * as os from "@pulumi/openstack";
import * as values from './values' <1>
import * as sg from './security-groups' <2>

const fs = require('fs')

// Create an OpenStack resource (Compute Instance)
const rancherInstance = new os.compute.Instance("rancher-sistemas-prod", {
	availabilityZone: "stic-prod",
	imageName: "Ubuntu 18.04 LTS",
	flavorName: "large",
	networks: [
		{
            name: "Sistemas-prod-net",
        }
	],
	keyPair: "os-sistemas",
	userData: fs.readFileSync('./rancher-setup.sh', 'utf8'),
	securityGroups: [sg.etcdSecGroup.name, sg.webSecGroup.name] <3>
});

// Associate a floating IP to the instance
const fipFloatingIpAssociate = new os.compute.FloatingIpAssociate("fip", {
    floatingIp: values.floatingIP, <4>
    instanceId: rancherInstance.id,
});

----
<1> Importación del archivo de parámetros y configuración del prefijo `values` para usar los objetos que ha exportado
<2> Importación del archivo de grupos de seguridad y configuración del prefijo `sg (security-groups)` para usar los objetos que ha exportado
<3> Uso de los grupos de seguridad del archivo de grupos de seguridad
<4> Uso de los parámetros del archivo de parámetros
====

## To-Do

## Eliminación de un proyecto

[NOTE]
====
The resources in the stack have been deleted, but the history and configuration associated with the stack are still maintained. 
If you want to remove the stack completely, run 'pulumi stack rm dev'.
====
