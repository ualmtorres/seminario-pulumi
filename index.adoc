////
NO CAMBIAR!!
Codificación, idioma, tabla de contenidos, tipo de documento
////
:encoding: utf-8
:lang: es
:toc: right
:toc-title: Tabla de contenidos
:doctype: book
:imagesdir: ./images
:linkattrs:

////
Nombre y título del trabajo
////
# Infraestructura como código con Pulumi
Servicio de las Tecnologías de la Información y las Comunicaciones - Universidad de Almería

image::logocloudstic.png[]

// NO CAMBIAR!! (Entrar en modo no numerado de apartados)
:numbered!: 


[abstract]
== Resumen
////
COLOCA A CONTINUACION EL RESUMEN
////
Los produtos habituales para la Infraestructura como código, como Terraform, Ansible, Chef, Puppet, y demás, suelen contar con su propia sintaxis, lo que dificulta en cierta medida su uso. Pulumi permite la creación de la infraestructura usando lenguajes de programación populares, como TypeScript, JavaScript, Python, Go o C#. De esta forma podemos usar nuestro lenguaje habitual para la creación de la infraestructura de forma sencilla, sin tener que pasar a otro lenguaje y beneficiándonos del manejo de variables y construcciones de programación habituales como los bucles y condiciones, aspectos básicos pero que no son demasiado sencillos de usar en el resto de productos.

////
COLOCA A CONTINUACION LOS OBJETIVOS
////
.Objetivos
* Aprender a hacer despliegues de proyectos sencillos.
* Realizar cambios sobre la infraestructura.
* Gestionar errores de despliegues corruptos.

[TIP]
====
[line-through]##Disponible el https://github.como/ualmtorres[repositorio] usado en este tutorial##.
====

// Entrar en modo numerado de apartados
:numbered:

## Introducción

La Infraestructura como código (IaC, Infrastructure as Code) permite la definición y mantenimiento de la infraestructura mediante código. Esto permite la automatización de la creación de la infraestructura en lugar de hacerlo manualmente. Se trata de un proceso declarativo en el que mediante una serie de archivos se especifica de forma declarativa la infraestructura y la configuración que se necesita (p.e. un entorno de backend con un volumen de almacenamiento, una máquina virtual con MySQL instalado y conectada al volumen creado, una máquina virtual con un framework instalado como Express, la configuración de red y de grupos de seguridad, ....). De esta forma se evita tener que preparar manualmente las máquinas virtuales, sistemas operativos, almacenamiento y configuración, obteniéndose en su lugar la definición de un entorno que garantiza ser replicable, documentando las especificaciones y evitando la realización de cambios sobre marcha y que no queden documentados. Con IaC, los cambios se hacen sobre el código y se aplican ejecutándola, en lugar de hacerlos en caliente mediante comandos sobre la infraestructura. Además, la práctica de control de versiones, como cualquier otro desarrollo software, permitirá llevar un control de cada uno de los cambios introducidos en la configuración de la infraestructura. 

Entre los productos más populares de IaC se encuentran Terraform, Ansible, Chef, Puppet, ... En estas propuestas, la infraestructura se especifica de formas muy variadas, como en https://ualmtorres.github.io/CursoAnsible/tutorial/#trueinstalaci-n-de-paquetes[formato YAML] en el caso de Ansible, o en su propio lenguaje DSL (Domain Specific Language) como el https://github.com/ualmtorres/terraform-examples/blob/master/GCP/05-instancia-aprovisionada/main.tf[HCL] (Hashicorp Configuration Language) de Terraform y el https://puppet.com/docs/puppet/7/lang_visual_index.html#lang_examples_resource-resource-declaration[Puppet Language] de Puppet, pasando por Chef, que usa https://www.tutorialspoint.com/chef/chef_testing_cookbooks.htm[Ruby como sintaxis] para la definición de la infraestructura. 

[NOTE]
====
En estos enlaces puedes consultar otros tutoriales sobre https://ualmtorres.github.io/SeminarioTerraform/[Terraform] y https://ualmtorres.github.io/CursoAnsible/tutorial/[Ansible].
====

En este contexto surge https://www.pulumi.com/[Pulumi], un nuevo producto de IaC que se diferencia del resto en que usa lenguajes de programación convencionales, como TypeScript, JavaScript, Python, Go o C#. Esto lo hace especialmente interesante, ya que no se tendrá que aprender un lenguaje extra para el manejo de infraestructura cloud y se facilita el uso de variables y construcciones de programación como bucles y condiciones.

Pulumi ofrece soporte para lo principales proveedores cloud, como Amazon, Google Cloud, Microsoft Azure, Digital Ocean, Linode, OpenStack, vSphere, y demás, así como para Kubernetes, proveedores de infraestructura, bases de datos, monitorización y sistemas de control de versiones.

En este tutorial nos centraremos en la creación de un cluster de Kubernetes gestionado con Rancher y usando OpenStack como proveedor de infraestructura. Usaremos TypeScript como lenguaje de desarrollo


## Configuración de Pulumi

La instalación la haremos siguiendo la https://www.pulumi.com/docs/get-started/install/[guía oficial de instalación]. 

* En macOS la haremos mediante https://brew.sh/[Homebrew] con `brew install pulumi`.
* En Windows la haremos mediante https://chocolatey.org/[Chocolatey] con `choco install pulumi`.
* En Linux la haremos ejecutando el script `curl -fsSL https://get.pulumi.com | sh`.

Una vez instalado comprobaremos que todo es correcto con:

[source, bash]
----
$ pulumi version
v3.7.0
----

## Flujo de trabajo con Pulumi

El flujo de trabajo habitual en Pulumi consiste en la creación del proyecto, codificación de la infraestuctura inicial, despliegue de cambios. Sin embargo, no se trata de un proceso secuencial, sino que en realidad, tras la creación del proyecto, se entra en un ciclo iterativo de codificación de infraestructura y despliegue de cambios.

El proyecto se crea con el comando `pulumi new` y normalmente le pasaremos una plantilla como argumento. En la plantilla se configura la plataforma con la que vamos a trabajar (proveedor cloud, base de datos, ...) y el lenguaje de programación que vamos a utilizar para codificar la infraestructura. Esto lo veremos en el apartado <<Creación y configuración inicial del proyecto>>.

Los cambios introducidos en el ciclo de desarrollo con Pulumi pueden deberse a la creación de código para nuevos recursos, y modificación o eliminación del código de recursos creados previamente. La forma de llevar a cabo estos cambios siempre es con `pulumi up`. Tras confirmar la acción de despliegue, los cambios se trasladarán a la infraestructura y Pulumi guardará _el estado del despliegue_, que consiste en anotar cada uno de los recursos configurados.

Cuando más adelante se introduzcan cambios en el código y se incluya nuevo código para nuevos recursos, y se modifique o elimine código de recursos creados previamente se comparará el último estado guardado del proyecto con el nuevo estado al que se llegaría tras aplicar los cambios. Tras confirmar la acción de despliegue, Pulumi sólo desplegaría los cambios, dejando intacto los recursos que no han sido modificados. En este sentido se dice que Pulumi es `idempotente` ya que no vuelve a crear un recurso que no ha sido modificado.

[NOTE]
====
Si eliminamos un recurso del código y ejecutamos `pulumi up` se eliminará ese recurso de la infraestructura. Por tanto, no hay operaciones de eliminación para cada recurso. Simplemente se elimina su código del proyecto y se despliegan los cambios comn `pulumi up`.
====

La infraestructura creada se elimina con `pulumi destroy`. Es una operación peligrosa ya que elimina toda la infraestructura y si hay datos o configuraciones almacenadas en el despliegue se corre el riesgo de pérdida de datos.

## Caso de uso. Creación de una máquina virtual configurada con Rancher en OpenStack

El caso de uso que estudiaremos parte de un proyecto OpenStack creado previamente. En dicho proyecto se configurarán mediante Pulumi los grupos de seguridad, se creará una instancia que se aprovisionará durante su inicio con Rancher y se finalizará asignándole una dirección IP flotante.

### Recursos del paquete Pulumi para OpenStack

De acuerdo con la https://www.pulumi.com/docs/reference/pkg/openstack/[documentación del paquete Pulumi para OpenStack], existen gran cantidad de módulos para la gestión de recursos OpenStacl con Pulumi, entre los que destacan almacenamiento de bloques para Cinder, instancias de cómputo para Nova, identidades para Keystone, imágenes para Glance, redes para Neutron y shares para Manila.

### Descarga de las credenciales del proyecto OpenStack

Desde la interfaz gráfica Horizon de OpenStack seguiremos estos casos para la descarga de credenciales del usuario en el proyecto OpenStack a utilizar.

* Seleccionar el proyecto en OpenStack en el desplegable de proyectos del usuario.
* En el desplegable del menú del usuario seleccionar `OpenStack RC File`.
* Cargar las credenciales descargadas con `source <credentials-filename>`. Introducir la contraseña solicitada de acceso a OpenStack.

[TIP]
====
Para usuarios de Windows se recomienda tener instalado https://ubuntu.com/wsl[WSL]. 
====

### Creación y configuración inicial del proyecto

Desde dentro de un directorio vacío creado para el proyecto crearemos el proyecto Pulumi con el comando `pulumi new`. Si no indicamos nada más, habrá que seleccionar el tipo de proyecto eligiendo tanto la plataforma como el lenguaje. A esta combinación de tipo de proyecto (AWS, Azure, Google Cloud, Kubernetes, Linode, OpenStack) y lenguaje (Go, JavaScript, TypeScript, Python, C#) se le conoce como plantilla. Una forma más rápida es pasar el parámetro de configuración de la plantilla directamente al crear el proyecto

[source,bash]
----
$ pulumi new openstack-typescript <1>
----
<1> Nuevo proyecto usando la plantilla con OpenStack como provider y TypeScript como lenguaje.

A continuación:

* aceptaremos el nombre del proyecto, cuyo valor predeterminado es el del directorio en el que se encuentra
* completaremos la descripción con `Configuración de MV OpenStack`
* aceptaremos el nombre del stack (`dev`).

[NOTE]
====
Un stack es un concepto similar al de entorno de despliegue de aplicaciones. Podremos tener stacks diferentes para desarrollo, staging y producción.
====

Una vez aceptadas las opciones de creación del proyecto se instalarán las dependencias del proyecto y uno instantes después el proyecto estará listo para ejecutarse. 

Como resultado tendremos un proyecto con la estructura siguiente:

[source,]
----
├── .gitignore
├── index.ts <1>
├── package.json <2>
├── Pulumi.yaml <3>
└── tsconfig.json
----
<1> Archivo con los recursos a desplegar. Incopora un ejemplo 
<2> Archivo de dependencias. La dependencia de OpenStack aparece como instalada al haber creado el proyecto con una plantilla de OpenStack
<3> Configuración del nombre y descripción del proyecto y runtime de ejecución

.Una instancia como ejemplo de recurso de OpenStack
****
Tras crear el proyecto con la plantilla de OpenStack, Pulumi incluye un ejemplo de recurso en el archivo `index.ts`. Se trata de la creación de una instancia OpenStack.

[source, ts]
----
...
import * as os from "@pulumi/openstack"; <1>

const instance = new os.compute.Instance("test", { <2>
	flavorName: "s1-2",
	imageName: "Ubuntu 16.04",
});
...
----
<1> Importación del paquete de recursos de OpenStack
<2> Creación de una instancia

Para la creación de la instancia:

* Se usa `os` como alias dado al paquete OpenStack.
* Se usa el módulo `compute` y el recurso `Instance`. 
* Se asigna un nombre (`test` en este caso)
* Se usa un objeto JSON para especificar los  https://www.pulumi.com/docs/reference/pkg/openstack/compute/instance/[ parámetros de configuración]. 
****

### Configuración de las reglas de seguridad

Las reglas de seguridad configuran el cortafuegos del proyecto de OpenStack. Para el ejemplo que nos ocupa, Rancher necesita inicialmente que estén abiertos los puertos TCP 80 y 443 para el tráfico HTTP (HTTP y HTTPS). Para implementarlo podemos incluir estas dos reglas de seguridad en el grupo `default` del proyecto o crear un grupo de seguridad específico para estas dos reglas. Posteriormente, al configurar la instancia se le aplicaría el grupo de seguridad `default` o el grupo específico para las reglas HTTP.En este ejemplo optamos por crear un grupo de seguridad específico.

[IMPORTANT]
====
Crear grupos de seguridad específicos para grupos de reglas de reglas de seguriddad es más laborioso que ir incluyendo las reglas en el grupo `default`. Sin embargo, provoca que haya instancias que tengan abiertos puertos de forma innecesaria, lo que puede derivar en un problema de seguridad. 
====

#### Creación de un grupo de seguridad

Los grupos de seguridad se crean con el recurso `SecGroup` del módulo `networking`. Basta con indicar un nombre para el grupo de seguridad y un JSON para las opciones. En nuestro caso incluiremos la descripción del grupo de seguridad.

[source,ts]
----
const webSecGroup = new os.networking.SecGroup("web", {
	description: "Web security group"
})
----

Esto define un grupo de seguridad asignado a `webSecGroup` lo que nos permite manipularlo posteriormente, como para añadirle reglas de seguridad.

#### Añadir reglas de seguridad

Las reglas de seguridad se añaden a los grupos de seguridad creando un recurso `SecGroupRule` del módulo `networking`. Se trata de indicar un nombre para la reglas de seguridad y un JSON para las opciones. En nuestro caso incluiremos una descripción, dirección, si es IPv4 o IPv6, el puerto abierto (definido como un rango), el protocolo, las direcciones IP remotas a las que se les da acceso y el grupo de seguridad al que se asigna la regla creada

[source,ts]
----
const web80 = new os.networking.SecGroupRule("web80", {
	description: "HTTP",
    direction: "ingress",
    ethertype: "IPv4",
    portRangeMax: 80,
    portRangeMin: 80,
    protocol: "tcp",
    remoteIpPrefix: '0.0.0.0/0',
    securityGroupId: webSecGroup.id, <1>
});

const web443 = new os.networking.SecGroupRule("web443", {
	description: "HTTPS",
    direction: "ingress",
    ethertype: "IPv4",
    portRangeMax: 443,
    portRangeMin: 443,
    protocol: "tcp",
    remoteIpPrefix: '0.0.0.0/0',
    securityGroupId: webSecGroup.id, <2>
});
----
<1> Asignación de la regla a un grupo de seguridad.
<2> Asignación de la regla a un grupo de seguridad.

#### Despliegue de la configuración de seguridad

La configuración de seguridad completa para un entorno con Rancher y Kubernetes residiendo en el mismo proyecto OpenStack incluye una gran variedad de grupos y reglas de seguridad. La documentación oficial de Rancher especifica la https://rancher.com/docs/rancher/v2.x/en/installation/requirements/ports/#ports-for-rancher-launched-kubernetes-clusters-using-node-pools[lista de puertos a abrir] para cada componente. 

Hacer una definición exhaustiva de todos los grupos y reglas de seguridad de un proyecto para producción está fuera del ámbito de este tutorial y nos limitaremos a incluir otro grupo de seguridad a modo de ejemplo para ver cómo configurar varios grupos de seguridad. Tomaremos como ejemplo la configuración de seguridad de los puertos 2379 y 2380 de la base de datos `etcd` que usa Kubernetes para el almacenamiento de la configuración.

Finalmente, la configuración inicial de seguridad quedaría definida así en el archivo `index.ts`.

[source,ts]
----
import * as os from "@pulumi/openstack";

const cidr = '192.168.129.0/24' <1>

// Create security group <2>
const etcdSecGroup = new os.networking.SecGroup("etcd", {
	description: "Kubernetes security group"
})

// Create security rule and assing to a security group <3>
const etcd2379 = new os.networking.SecGroupRule("etcd2379", {
	description: "etcd",
    direction: "ingress",
    ethertype: "IPv4",
    portRangeMax: 2379,
    portRangeMin: 2379,
    protocol: "tcp",
    remoteIpPrefix: cidr, <4>
    securityGroupId: etcdSecGroup.id, <5>
});

// Create security rule and assing to a security group
const etcd2380 = new os.networking.SecGroupRule("etcd2380", {
	description: "etcd",
    direction: "ingress",
    ethertype: "IPv4",
    portRangeMax: 2380,
    portRangeMin: 2380,
    protocol: "tcp",
    remoteIpPrefix: cidr,
    securityGroupId: etcdSecGroup.id,
});

// Create web security group
const webSecGroup = new os.networking.SecGroup("web", {
	description: "Web security group"
})

// Create security rule and assing to a security group
const web80 = new os.networking.SecGroupRule("web80", {
	description: "HTTP",
    direction: "ingress",
    ethertype: "IPv4",
    portRangeMax: 80,
    portRangeMin: 80,
    protocol: "tcp",
    remoteIpPrefix: '0.0.0.0/0',
    securityGroupId: webSecGroup.id,
});

// Create security rule and assing to a security group
const web443 = new os.networking.SecGroupRule("web443", {
	description: "HTTPS",
    direction: "ingress",
    ethertype: "IPv4",
    portRangeMax: 443,
    portRangeMin: 443,
    protocol: "tcp",
    remoteIpPrefix: '0.0.0.0/0',
    securityGroupId: webSecGroup.id,
});

----
<1> CIDR para restringir el acceso remoto a instancias que se apliquen reglas de seguridad para ese CIDR
<2> Creación de un grupo de seguridad
<3> Creación de una regla para un grupo de seguridad
<4> Aplicación del CIDR a la regla de seguridad
<5> Asignación de la regla de seguridad a un grupo de seguridad

Los cambios se desplegarían con `pulumi up` y seleccionando la opción `yes`. La opción `details` muestra los detalles de cada uno de los recursos a crear, modificar o eliminar en la infraestructura.

La figura siguiente muestra el efecto del despliegue con los dos grupos de seguridad creados.

image::grupos-de-seguridad.png[]

La figura siguiente ilustra las reglas de seguridad del grupo `web`. Para ese grupo se permitía el acceso a estos puertos desde cualquier dirección de Internet.

image::reglas-de-seguridad-web.png[]

### Script de inicialización de Rancher

[source,bash]
----
#!/bin/bash

RANCHERPASSWORD='yourpasswordhere'
RANCHERSERVER='https://your.url.here.com'

echo "Instalando Docker"

apt-get update
apt-get install -y \
    apt-transport-https \
    ca-certificates \
    curl \
    software-properties-common \
    jq
curl -fsSL https://download.docker.com/linux/ubuntu/gpg | apt-key add -
apt-key fingerprint 0EBFCD88
add-apt-repository \
   "deb [arch=amd64] https://download.docker.com/linux/ubuntu \
   $(lsb_release -cs) \
   stable"
apt-get update
apt-get install -y docker-ce
groupadd docker
usermod -aG docker ubuntu
systemctl enable docker

echo "Obteniendo certificados"

mkdir /home/ubuntu/rancherdata
mkdir /home/ubuntu/certificados

wget -O /home/ubuntu/certificados/star_stic_ual_es.crt https://your.certificate.server.here.com/star_stic_ual_es_completa.crt
wget -O /home/ubuntu/certificados/star_stic_ual_es.key https://your.certificate.server.here.com/star_stic_ual_es.key
wget -O /home/ubuntu/certificados/DigiCertCA.crt https://your.certificate.server.here.com/DigiCertCA.crt

docker run \
    --privileged -d \
    --restart=unless-stopped \
    -p 80:80 -p 443:443 \
    -v /home/ubuntu/rancherdata:/var/lib/rancher \
    -v /home/ubuntu/certificados/star_stic_ual_es.crt:/etc/rancher/ssl/cert.pem \
    -v /home/ubuntu/certificados/star_stic_ual_es.key:/etc/rancher/ssl/key.pem \
    -v /home/ubuntu/certificados/DigiCertCA.crt:/etc/rancher/ssl/cacerts.pem \
    --name rancher \
    rancher/rancher:v2.5.8 \
    --features=unsupported-storage-drivers=true

echo "Configurando Rancher"

while ! curl -k https://localhost/ping; do sleep 3; done

# First Rancher Login
LOGINRESPONSE=`curl -s 'https://127.0.0.1/v3-public/localProviders/local?action=login' -H 'content-type: application/json' --data-binary '{"username":"admin","password":"admin"}' --insecure`
LOGINTOKEN=`echo $LOGINRESPONSE | jq -r .token`

# Change password
curl -s 'https://127.0.0.1/v3/users?action=changepassword' \
    -H 'content-type: application/json' \
    -H "Authorization: Bearer $LOGINTOKEN" \
    --data-binary '{"currentPassword":"admin","newPassword":"'$RANCHERPASSWORD'"}' \
    --insecure

# Configure server-url
curl -s 'https://127.0.0.1/v3/settings/server-url' \
    -H 'content-type: application/json' \
    -H "Authorization: Bearer $LOGINTOKEN" \
    -X PUT \
    --data-binary '{"name":"server-url","value":"'$RANCHERSERVER'"}' \
    --insecure

# Activate OpenStack node driver
curl -s 'https://127.0.0.1/v3/nodeDrivers/openstack?action=activate' \
    -H 'content-type: application/json' \
    -H "Authorization: Bearer $LOGINTOKEN" \
    -X POST \
    --insecure

exit 0
----



## Eliminación de un proyecto

[NOTE]
====
The resources in the stack have been deleted, but the history and configuration associated with the stack are still maintained. 
If you want to remove the stack completely, run 'pulumi stack rm dev'.
====
